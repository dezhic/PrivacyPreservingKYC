pragma circom 2.0.0;

/*
The Holder generates the token
The token contains
- enc(((DID_I, DID_HI), DID_HV, DID_V), PK_G)
- encrypted I's signature of (DID_I, DID_H(I)), to ensure that the (DID_I, DID_HI) is endorsed by I. avoid signature correlationÂ 

(DID_I, DID_H(I)) can be verified and signed by I, which is recognized by V

The validity proof proves that the token contains verified (DID_I, DID_H(I)) by
- checking the token contains a signature from I (but V does not know the signature) , and the unknown signature signs unknown ((DID_I, DID_HI) which is included in enc(((DID_I, DID_HI), DID_HV, DID_V), PK_G)
Both the validity proof and the token are generated by Holder
*/

/*
    The following template can proof that given the output `c`, we are able to provide
    an input `a` and an input `b` that satisfies `a * b == c`.
    Or in other words, the proof "witnessed" our procedure of computing `c` by `a * b`,
    and can provide a proof of the witness without disclosing `a` and `b`

    So, in the zkKYC case, the inputs are the encryption key PK_G and the encrypted values
    DID_I, DID_HI and the signature of Issuer, and the output is the encrypted object and the
    public key of Issuer PK_I. Then, it proves to the Verifier that the encrypted object has
    the identity information provided by the Issuer I.
*/

// TODO: Implement the signing algorithm here

template Multiplier(n) {
    signal input a;
    signal input b;
    signal output c;

    signal int[n];

    int[0] <== a*a + b;
    for (var i=1; i<n; i++) {
    int[i] <== int[i-1]*int[i-1] + b;
    }

    c <== int[n-1];
}

component main = Multiplier(1000);
